# 题目描述	2021年5月15日11:43:48

https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/

> 一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。
>
>  
>
> **示例 1：**
>
> 输入：nums = [4,1,4,6]
>
> 输出：[1,6] 或 [6,1]
>
> **示例 2：**
>
> 输入：nums = [1,2,10,4,1,4,3,3]
>
> 输出：[2,10] 或 [10,2]
>
> **限制：**
>
> 2 <= nums.length <= 10000

# 题解

## 解法一：分组异或

如果数组中只有一个只出现一次的数字，其余数字都出现了两次。那么我们很直观的能想到用异或的方式，把数组中所有数字异或，从而使出现过两次的数字都给==连连看==消掉。

![image-20210515125332478](https://gitee.com/mw515031/image/raw/master/image/image-20210515125332478.png)

但是本题有两个数字只出现一次，导致我们无法直接那么简单粗暴的异或。

![image-20210515125249104](https://gitee.com/mw515031/image/raw/master/image/image-20210515125249104.png)

所以我们要想办法能不能把这这一个复杂问题，拆成两个简单问题。也就是说把一个数组分成两部分

![image-20210515130555440](https://gitee.com/mw515031/image/raw/master/image/image-20210515130555440.png)

这样的话，对每个部分进行异或，就能得到两个目标答案。

但是这个分组要满足两个条件：

1. 两个只出现一次的数字要分在不同的组里
2. 相同的数字要分在同一组里

**现在我们只需要考虑怎么分组即可。**

我们假设两个不同的数字为：`a,b`

把数组中的所有数字异或，其实就等于把ab异或，结果记为`x`。我们考虑一下`a,b,x`三者的二进制的关系。

```java
//异或的规则
0^0=0;
0^1=1;
1^0=1;
1^1=0;
//即两数不同，结果为一
```

所以如果x的某一二进制位为1，那么就代表ab两数在这一位上的二进制不同。二进制只有1和0，且我们正好要把数组分成两组，所以我们就可以通过这一位上ab两数具体为0或者1，把数组分成两个部分。

为什么可以这样分？

1. 两个一样的数字，他们二进制也一定是相同的。所以他们一定能分到同一组里，因此满足条件1.
2. 异或结果为1的bit位，代表在这一位上ab的bit位不同，所以一定会分到不同的组，因此满足条件2.

所以这里就分成了两个步骤：

1. 找到一个异或结果为1的bit位（这里可以是任意一位，这里选择了不为零的最低位）
2. 根据这一位上bit位为0或者1，把数组分两组异或。

**技巧：**

我们考虑一下找到最低不为0的bit位的常规步骤。

1. `num&1`，`num>>>1`找到第一个不为0的bit位在第几位
2. 把每一个bit位的这一位右移到最低位，然后进行`num&1`判断这一位是否为0

整个步骤显得不是十分优雅，下面介绍一种比较优雅的方式。

- 把第i位为1，其余位为0的数和x做&运算，判断是否为0，从而判断该位是否为1.
- 如果没有，该数左移
- 这样就得到了一个目标位为1，其余位为0的一个辅助数字
- 拿这个数字跟数组中的每个数字进行&，判断是否为0，从而判断该位是否为1.

```java
        int div = 1;
        while ((div & x) == 0) {
            div <<= 1;
        }
```

**算法步骤：**

先对所有数字进行一次异或，得到两个出现一次的数字的异或值。

在异或结果中找到任意为 1 的位。

根据这一位对所有的数字进行分组。

在每个组内进行异或操作，得到两个数字。

```java
class Solution {
    public int[] singleNumbers(int[] nums) {
        //得到两个出现一次的数字的异或值
        int x=0;
        for(int n:nums){
            x^=n;
        }
        //在异或结果中找到最低不为0的bit位
        int div = 1;
        while ((div & x) == 0) {//==优先级高于&，所以括号是必要的
            div <<= 1;
        }
        //分组异或
        int a=0,b=0;
        for(int n:nums){
            if((n&div)==0){
                a^=n;
            }else{
                b^=n;
            }
        }
        return new int[]{a,b};
    }
}
```








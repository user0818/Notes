## 题目描述	2021年4月25日21:32:24

> 请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。
>
>  
>
> 示例 1：
>
> 输入：00000000000000000000000000001011
> 输出：3
> 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
> 示例 2：
>
> 输入：00000000000000000000000010000000
> 输出：1
> 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
> 示例 3：
>
> 输入：11111111111111111111111111111101
> 输出：31
> 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
>
>
> 提示：
>
> 输入必须是长度为 32 的 二进制串 。
>

## 题解

### 解法一：java内置函数

java中有专门计算整数的二进制中有多少1的库函数：`Integer.bitCount()`

### 解法二：异或法

假设有8位二级制如下：

![image-20210425213630848](https://gitee.com/mw515031/image/raw/master/image/image-20210425213630848.png)

我们先关注第一次出现1的低5位，这时如果对该数进行==减一==操作会发生什么变化：

![image-20210425214302149](https://gitee.com/mw515031/image/raw/master/image/image-20210425214302149.png)

我们发现这里的每一位都进行了反转。让我们再来回忆一下与运算的运算法则：

![image-20210425220639914](https://gitee.com/mw515031/image/raw/master/image/image-20210425220639914.png)

观察上述表格可知，对于与运算，若二者相同，则结果不变；若二者不同，则结果为0。因此套用到第二个图可知，前面这一部分若进行与运算，则结果不变；而后半部分进行与运算，结果全部为0。

整体的来看，把一个数减一再取与，相当于把这个数二进制最低位上的1给减掉。

那么问题就简单了，我们只需要看看这个输入的值这样操作几次才为0就可知道这个数到底有多少个二进制的1。

```java
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int count=0;
        while(n!=0){
            if(n%2!=0){
                ++count;
            }
            n>>>=1;
        }
        return count;
    }
}
```


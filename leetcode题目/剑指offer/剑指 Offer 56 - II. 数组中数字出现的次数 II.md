## 题目描述	2021年5月14日16:29:34

https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/

> 在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。
>
>  
>
> **示例 1：**
>
> 输入：nums = [3,4,3,3]
>
> 输出：4
>
> **示例 2：**
>
> 输入：nums = [9,1,7,9,7,9,7]
>
> 输出：1
>
> **限制：**
>
> 1 <= nums.length <= 10000
>
> 1 <= nums[i] < 2^31

## 题解



![image-20210514163147896](https://gitee.com/mw515031/image/raw/master/image/image-20210514163147896.png)

##题解

### 解法一：有限状态自动机

我们把目光放到一个bit位上，通过迭代的眼光来观察它的变化。因为对每个bit位来说，我们的思路是对他们加和再取模3。那么不论是最后取模还是每一步都取模，结果是一样的。而当我们每一步都取模3时，这一位的加和就只有三种可能性，分别是：`0,1,2`。由于我们是迭代着进行加法运算，所以这三种状态是一步一步地按顺序转换的。

- 若输入二进制位 11 ，则状态按照以下顺序转换`0-->1-->2-->0……`；
- 若输入二进制位 00 ，则状态不变。

![image-20210514165028455](https://gitee.com/mw515031/image/raw/master/image/image-20210514165028455.png)

这里有三种状态，所以我们要想保存这三种状态至少需要两个bit位。所以分别为：`00-->01-->10-->00……`。为了方便提及，我们给这两个bit位取个名字，分别叫做two、one。分别对应高位和低位。

同理这三种状态的转换可表示为：

![image-20210514165629324](https://gitee.com/mw515031/image/raw/master/image/image-20210514165629324.png)

接下来，我们通过观察状态转换表，看看能不能推导出了一个公式来表达状态转换。

计算 oneone 方法：

设当前状态为 twotwo oneone ，此时输入二进制位 nn 。如下图所示，通过对状态表的情况拆分，可推出 oneone 的计算方法为：

```pseudocode
if two == 0:
  if n == 0:
    one = one
  if n == 1:
    one = ~one
if two == 1:
    one = 0
```


引入 异或运算 ，可将以上拆分简化为：

```pseudocode
if two == 0:
    one = one ^ n
if two == 1:
    one = 0
```


引入 与运算 ，可继续简化为：


one = one ^ n & ~two

![image-20210514170115981](https://gitee.com/mw515031/image/raw/master/image/image-20210514170115981.png)

同理可以得出计算two的公式：`two = two ^ n & ~one`

**返回值：**

以上是对数字的二进制中 “一位” 的分析，而 int 类型的其他 31 位具有相同的运算规则，因此可将以上公式直接套用在 32 位数上。

遍历完所有数字后，各二进制位都处于状态 00 和状态 01 （取决于 “只出现一次的数字” 的各二进制位是 1 还是 0 ）（因为数组中的数字要么出现一次，要么出现三次，所以模3的结果为0或者1），而此两状态是由 one 来记录的（此两状态下 twos 恒为 0 ），因此返回 ones 即可。

### 解法二：遍历统计

使用 **与运算** ，可获取二进制数字 num的最右一位 n1 ：

```java
n1=num&1;
```

配合**无符号右移**，即可获取num所有位的值(n1~n32)。

```
num=num>>>1
```

建立一个长度为32的数组，分别存储每一位中1出现的次数

然后在对数组中的每一位取模3

最后计算这个数组按位保存的二进制对应的十进制是多少。

```java
class Solution {
    public int singleNumber(int[] nums) {
        int[] counts = new int[32];
        for(int num : nums) {
            for(int j = 0; j < 32; j++) {
                counts[j] += num & 1;
                num >>>= 1;
            }
        }
        int res = 0, m = 3;
        for(int i = 0; i < 32; i++) {
            res <<= 1;
            res |= counts[31 - i] % m;
        }
        return res;
    }
}
```




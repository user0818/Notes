## 题目描述	2020年10月26日09:53:38

https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements/description/

给定一个长度为 *n* 的**非空**整数数组，找到让数组所有元素相等的最小移动次数。每次移动将会使 *n* - 1 个元素增加 1。

 

**示例:**

```
输入:
[1,2,3]

输出:
3

解释:
只需要3次移动（注意每次移动会增加两个元素的值）：

[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]
```

## 题解

### 解法一：数学法

该方法基于以下思路：将除了一个元素之外的全部元素+1，等价于将该元素-1，因为我们只对元素的相对大小感兴趣。因此，该问题简化为需要进行的减法次数。

显然，我们只需要将所有的数都减到最小的数即可。为了找到答案，我们不需要真的操作这些元素。而是找到最小值，然后对每个数的和减去最小值的n倍。

```java
public class Solution {
    public int minMoves(int[] nums) {
        int moves = 0, min = Integer.MAX_VALUE;
        for (int i = 0; i < nums.length; i++) {
            moves += nums[i];
            min = Math.min(min, nums[i]);
        }
        return moves - min * nums.length;
    }
}

```

上述move可能会非常大导致数组越界。可以先找到最小值，然后逐个计算。改进后：

```java
public class Solution {
    public int minMoves(int[] nums) {
        int moves = 0, min = Integer.MAX_VALUE;
        for (int i = 0; i < nums.length; i++) {
            min = Math.min(min, nums[i]);
        }
        for (int i = 0; i < nums.length; i++) {
            moves += nums[i] - min;
        }
        return moves;
    }
}

```

